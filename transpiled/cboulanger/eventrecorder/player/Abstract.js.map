{
  "version": 3,
  "sources": [
    "/home/travis/build/cboulanger/eventrecorder/source/class/cboulanger/eventrecorder/player/Abstract.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "core",
    "Object",
    "include",
    "cboulanger",
    "eventrecorder",
    "MHelperMethods",
    "statics",
    "utilityFunctions",
    "waitForCondition",
    "fn",
    "interval",
    "timeout",
    "timeoutMsg",
    "Promise",
    "resolve",
    "reject",
    "intervalId",
    "setInterval",
    "clearInterval",
    "setTimeout",
    "Error",
    "waitForEvent",
    "qxObjOrId",
    "type",
    "expectedData",
    "qxObj",
    "lang",
    "Type",
    "isString",
    "Id",
    "getQxObject",
    "getTimeout",
    "timeoutId",
    "removeListener",
    "changeEventHandler",
    "app",
    "Init",
    "getApplication",
    "eventdata",
    "e",
    "event",
    "Data",
    "getData",
    "undefined",
    "warn",
    "addListenerOnce",
    "isArray",
    "length",
    "entries",
    "index",
    "expectedItem",
    "JSON",
    "stringify",
    "isRegExp",
    "match",
    "toString",
    "info",
    "clearTimeout",
    "properties",
    "mode",
    "check",
    "init",
    "apply",
    "useDefaultDelay",
    "nullable",
    "maxDelay",
    "canReplayInBrowser",
    "canExportExecutableCode",
    "events",
    "construct",
    "__commands",
    "__macros",
    "__macro_stack",
    "_globalRef",
    "window",
    "name",
    "members",
    "__macro_stack_index",
    "__vars",
    "__promises",
    "_applyMode",
    "value",
    "old",
    "_addCommands",
    "commands",
    "concat",
    "sort",
    "a",
    "b",
    "getCommands",
    "_tokenize",
    "line",
    "Assert",
    "assertString",
    "tokens",
    "token",
    "prevChar",
    "insideQuotes",
    "trim",
    "split",
    "char",
    "parse",
    "push",
    "_translateLine",
    "startsWith",
    "addComment",
    "substr",
    "command",
    "args",
    "method_name",
    "replace",
    "translatedLine",
    "isInAwaitBlock",
    "_addPromiseToAwaitStack",
    "_handleMeta",
    "script",
    "expandVariables",
    "lines",
    "var_def",
    "_getMacro",
    "macro_name",
    "macro_lines",
    "i",
    "map",
    "l",
    "RegExp",
    "_defineVariables",
    "getOwnPropertyNames",
    "key",
    "_translateVariables",
    "var_name",
    "var_content",
    "_generateUtilityFunctionsCode",
    "filter",
    "Boolean",
    "join",
    "_play",
    "steps",
    "step",
    "getRunning",
    "debug",
    "fireDataEvent",
    "getMode",
    "code",
    "repeat",
    "result",
    "eval",
    "replay",
    "setRunning",
    "await_block",
    "cmd_hide_info",
    "translate",
    "_translate",
    "translatedLines",
    "new_lines",
    "translation",
    "generateWaitForConditionCode",
    "condition",
    "timeoutmsg",
    "getInterval",
    "generateWaitForEventCode",
    "id",
    "data",
    "generateWaitForEventTimoutFunction",
    "comment",
    "escapeRegexpChars",
    "s",
    "createRegexpForJsonComparison",
    "searchExp",
    "foundRegExps",
    "m",
    "slice",
    "promiseCode",
    "getExportFileExtension",
    "cmd_assert_uri",
    "uri",
    "cmd_assert_match_uri",
    "uri_regexp",
    "cmd_config_set_mode",
    "cmd_define",
    "cmd_end",
    "cmd_await_all",
    "player",
    "Abstract"
  ],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAAA,KAAGC,SAAH,CAAaC,oBAAb,CAAkCC,aAAlC,EAmBAH,GAAGI,KAAH,CAASC,MAAT,CAAgB,0CAAhB,EAA4D;AAC1DC,YAASN,GAAGO,IAAH,CAAQC,MADyC;AAE1DC,aAAU,CAACC,WAAWC,aAAX,CAAyBC,cAA1B,CAFgD;;AAI1DC,aAAS;AACPC,wBAAmB;AACjB;;;;;;;;;;AAUAC,0BAAkB,0BAASC,EAAT,EAAsD;AAAA,cAAzCC,QAAyC,uEAAhC,GAAgC;AAAA,cAA3BC,OAA2B,uEAAnB,KAAmB;AAAA,cAAZC,UAAY;;AACtE,iBAAO,IAAIC,OAAJ,CAAa,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACvC,gBAAIC,aAAaC,YAAY,YAAM;AACjC,kBAAIR,IAAJ,EAAU;AACRS,8BAAcF,UAAd;AACAF;AACD;AACF,aALgB,EAKdJ,QALc,CAAjB;AAMAS,uBAAW,YAAM;AACfD,4BAAcF,UAAd;AACAD,qBAAO,IAAIK,KAAJ,CAAUR,8CAAV,CAAP;AACD,aAHD,EAGGD,OAHH;AAID,WAXM,CAAP;AAYD,SAxBgB;;AA0BjB;;;;;;;;;;;;;;;;AAgBAU,sBAAc,sBAASC,SAAT,EAAoBC,IAApB,EAA0BC,YAA1B,EAAwCb,OAAxC,EAAiDC,UAAjD,EAA6D;AACzE,cAAIa,QAAQH,SAAZ;AACA,cAAI7B,GAAGiC,IAAH,CAAQC,IAAR,CAAaC,QAAb,CAAsBN,SAAtB,CAAJ,EAAsC;AACpCG,oBAAQhC,GAAGO,IAAH,CAAQ6B,EAAR,CAAWC,WAAX,CAAuBR,SAAvB,CAAR;AACA,gBAAI,CAACG,KAAL,EAAY;AACV,oBAAM,IAAIL,KAAJ,wBAA+BE,SAA/B,CAAN;AACD;AACF;AACDX,oBAAUA,WAAW,KAAKoB,UAAL,EAArB;;AAEA,iBAAO,IAAIlB,OAAJ,CAAa,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACvC;AACA,gBAAIiB,YAAYb,WAAW,YAAM;AAC/BM,oBAAMQ,cAAN,CAAqBV,IAArB,EAA2BW,kBAA3B;AACAnB,qBAAO,IAAIK,KAAJ,CAAUR,+CAA4CW,IAA5C,MAAV,CAAP;AACD,aAHe,EAGbZ,OAHa,CAAhB;;AAKA;AACA,gBAAIuB,qBAAqB,SAArBA,kBAAqB,IAAK;AAC5B,kBAAIC,MAAM1C,GAAGO,IAAH,CAAQoC,IAAR,CAAaC,cAAb,EAAV;AACA,kBAAIC,YAAYC,aAAa9C,GAAG+C,KAAH,CAASjB,IAAT,CAAckB,IAA3B,GAAkCF,EAAEG,OAAF,EAAlC,GAAgDC,SAAhE;AACA,kBAAInB,iBAAiBmB,SAArB,EAAgC;AAC9B,oBAAIL,cAAcK,SAAlB,EAA6B;AAC3BR,sBAAIS,IAAJ,oCAA0CrB,IAA1C,oBAA6DE,KAA7D;AACAA,wBAAMoB,eAAN,CAAsBtB,IAAtB,EAA4BW,kBAA5B;AACA;AACD;AACD,oBAAIzC,GAAGiC,IAAH,CAAQC,IAAR,CAAamB,OAAb,CAAqBtB,YAArB,KAAsC/B,GAAGiC,IAAH,CAAQC,IAAR,CAAamB,OAAb,CAAqBR,SAArB,CAAtC,IAAyEd,aAAauB,MAAtF,IAAgGvB,aAAa,CAAb,aAA2B/B,GAAGO,IAAH,CAAQC,MAAvI,EAA+I;AAC7I;AAD6I;AAAA;AAAA;;AAAA;AAE7I,yCAAkCuB,aAAawB,OAAb,EAAlC,8HAA0D;AAAA;;AAAA;;AAAA,0BAAhDC,KAAgD;AAAA,0BAAzCC,YAAyC;;AACxD,0BAAIA,iBAAiBZ,UAAUW,KAAV,CAArB,EAAuC;AACrCd,4BAAIS,IAAJ,oCAA0CrB,IAA1C,oBAA6DE,KAA7D;AACAA,8BAAMoB,eAAN,CAAsBtB,IAAtB,EAA4BW,kBAA5B;AACA;AACD;AACF;AAR4I;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAS9I,iBATD,MASO;AACL;AACA,sBAAI;AACFI,gCAAYa,KAAKC,SAAL,CAAeb,EAAEG,OAAF,EAAf,CAAZ;AACD,mBAFD,CAEE,OAAOH,CAAP,EAAU;AACV,0BAAM,IAAInB,KAAJ,oCAA2CG,IAA3C,oBAA8DE,KAA9D,sDAAN;AACD;AACD,sBAAIhC,GAAGiC,IAAH,CAAQC,IAAR,CAAa0B,QAAb,CAAsB7B,YAAtB,CAAJ,EAAyC;AACvC;AACA,wBAAI,CAACc,UAAUgB,KAAV,CAAgB9B,YAAhB,CAAL,EAAoC;AAClCW,0BAAIS,IAAJ,oCAA0CrB,IAA1C,oBAA6DE,KAA7D,kCAA+FD,aAAa+B,QAAb,EAA/F,eAAgIjB,SAAhI;AACAb,4BAAMoB,eAAN,CAAsBtB,IAAtB,EAA4BW,kBAA5B;AACA;AACD;AACF,mBAPD,MAOO;AACL;AACA,wBAAI;AACFV,qCAAe2B,KAAKC,SAAL,CAAe5B,YAAf,CAAf;AACD,qBAFD,CAEE,OAAOe,CAAP,EAAU;AACV,4BAAM,IAAInB,KAAJ,8BAAqCG,IAArC,oBAAwDE,KAAxD,yDAAN;AACD;AACD,wBAAIa,cAAcd,YAAlB,EAAgC;AAC9BW,0BAAIS,IAAJ,oCAA0CrB,IAA1C,oBAA6DE,KAA7D,oBAAiF0B,KAAKC,SAAL,CAAe5B,YAAf,CAAjF,gBAAwH2B,KAAKC,SAAL,CAAed,SAAf,CAAxH;AACAb,4BAAMoB,eAAN,CAAsBtB,IAAtB,EAA4BW,kBAA5B;AACA;AACD;AACF;AACF;AACF;AACDC,kBAAIqB,IAAJ,oCAA0CjC,IAA1C,oBAA6DE,KAA7D;AACAgC,2BAAazB,SAAb;AACAlB,sBAAQwB,SAAR;AACD,aAlDD;;AAoDA;AACAb,kBAAMoB,eAAN,CAAsBtB,IAAtB,EAA4BW,kBAA5B;AACD,WA9DM,CAAP;AA+DD;AAnHgB;AADZ,KAJiD;;AA4H1DwB,gBAAY;AACV;;;;;;;AAOAC,YAAM;AACJC,eAAO,CAAC,MAAD,EAAS,cAAT,CADH;AAEJpB,eAAO,YAFH;AAGJqB,cAAM,cAHF;AAIJC,eAAO;AAJH,OARI;;AAeV;;;AAGAnD,eAAS;AACPiD,eAAO,QADA;AAEPC,cAAM;AAFC,OAlBC;;AAuBV;;;AAGAnD,gBAAU;AACRkD,eAAO,QADC;AAERC,cAAM;AAFE,OA1BA;;AA+BV;;;AAGAE,uBAAiB;AACfH,eAAO,SADQ;AAEfI,kBAAU,KAFK;AAGfH,cAAM;AAHS,OAlCP;;AAwCV;;;AAGAI,gBAAU;AACRL,eAAO,QADC;AAERC,cAAM;AAFE,OA3CA;;AAgDV;;;AAGAK,0BAAoB;AAClBN,eAAO,SADW;AAElBI,kBAAU,KAFQ;AAGlBH,cAAM,KAHY;AAIlBrB,eAAO;AAJW,OAnDV;;AA0DV;;;AAGA2B,+BAAyB;AACvBP,eAAO,SADgB;AAEvBI,kBAAU,KAFa;AAGvBH,cAAM,KAHiB;AAIvBrB,eAAO;AAJgB;AA7Df,KA5H8C;;AAiM1D4B,YAAQ;AACN;;;;AAIA,kBAAa;AALP,KAjMkD;;AAyM1D;;;AAGAC,eAAW,qBAAW;AACpB;AACA,WAAKC,UAAL,GAAkB,EAAlB;AACA,WAAKC,QAAL,GAAgB,EAAhB;AACA,WAAKC,aAAL,GAAqB,EAArB;AACA,WAAKC,UAAL,GAAkB,sBAAlB;AACAC,aAAO,KAAKD,UAAZ,IAA0B,IAA1B;AACA;AACA;AARoB;AAAA;AAAA;;AAAA;AASpB,8BAAuBxE,OAAO+C,OAAP,CAAe,yCAAqBzC,gBAApC,CAAvB,mIAA8E;AAAA;;AAAA;;AAAA,cAApEoE,IAAoE;AAAA,cAA9DlE,EAA8D;;AAC5EiE,iBAAOC,IAAP,IAAelE,EAAf;AACD;AAXmB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYrB,KAxNyD;;AA0N1D;;;AAGAmE,aACA;AACE;;;AAGAH,kBAAY,IAJd;;AAME;;;AAGAH,kBAAY,IATd;;AAWE;;;;AAIAC,gBAAW,IAfb;;AAiBE;;;;;AAKAC,qBAAe,IAtBjB;;AAwBE;;;;AAIAK,2BAAqB,CAAC,CA5BxB;;AA8BE;;;AAGAC,cAAQ,IAjCV;;AAmCE;;;AAGAC,kBAAY,IAtCd;;AAwCE;;;;;;AAMAC,gBA9CF,sBA8CaC,KA9Cb,EA8CoBC,GA9CpB,EA8CyB,CAAE,CA9C3B;;;AAgDE;;;;;AAKAC,kBArDF,wBAqDeC,QArDf,EAqDyB;AACrB,aAAKd,UAAL,GAAkB,KAAKA,UAAL,CAAgBe,MAAhB,CAAuBD,QAAvB,EAAiCE,IAAjC,CAAsC,UAACC,CAAD,EAAIC,CAAJ;AAAA,iBAAUD,EAAEZ,IAAF,GAASa,EAAEb,IAArB;AAAA,SAAtC,CAAlB;AACD,OAvDH;;;AAyDE;;;;;AAKAc,iBA9DF,yBA8DgB;AACZ,eAAO,KAAKnB,UAAZ;AACD,OAhEH;;;AAkEE;;;;;;;;AAQAoB,eA1EF,qBA0EYC,IA1EZ,EA0EkB;AACdlG,WAAGO,IAAH,CAAQ4F,MAAR,CAAeC,YAAf,CAA4BF,IAA5B;AACA,YAAIG,SAAS,EAAb;AACA,YAAIC,QAAQ,EAAZ;AACA,YAAIC,WAAS,EAAb;AACA,YAAIC,eAAe,KAAnB;AALc;AAAA;AAAA;;AAAA;AAMd,gCAAiBN,KAAKO,IAAL,GAAYC,KAAZ,CAAkB,EAAlB,CAAjB,mIAAwC;AAAA,gBAA/BC,IAA+B;;AACtC,oBAAQA,IAAR;AACE,mBAAK,IAAL;AACEH,+BAAa,CAACA,YAAd;AACAF,yBAASK,IAAT;AACA;AACF,mBAAK,GAAL;AACE;AACA,oBAAIH,YAAJ,EAAkB;AAChBF,2BAASK,IAAT;AACA;AACD;AACD;AACA,oBAAIJ,aAAa,GAAjB,EAAsB;AACpB;AACA,sBAAI;AACFD,4BAAQ5C,KAAKkD,KAAL,CAAWN,KAAX,CAAR;AACD,mBAFD,CAEE,OAAOxD,CAAP,EAAU,CAAE;AACduD,yBAAOQ,IAAP,CAAYP,KAAZ;AACAA,0BAAQ,EAAR;AACD;AACD;AACF;AACEA,yBAASK,IAAT;AAtBJ;AAwBAJ,uBAAWI,IAAX;AACD;AAhCa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAiCd,YAAIL,MAAMhD,MAAV,EAAkB;AAChB,cAAI;AACFgD,oBAAQ5C,KAAKkD,KAAL,CAAWN,KAAX,CAAR;AACD,WAFD,CAEE,OAAOxD,CAAP,EAAU,CAAE;AACduD,iBAAOQ,IAAP,CAAYP,KAAZ;AACD;AACD,eAAOD,MAAP;AACD,OAlHH;;;AAoHE;;;;;;;AAOAS,oBA3HF,0BA2HiBZ,IA3HjB,EA2HuB;AACnB;AACA,YAAIA,KAAKa,UAAL,CAAgB,GAAhB,CAAJ,EAA0B;AACxB,iBAAO,KAAKC,UAAL,CAAgBd,KAAKe,MAAL,CAAY,CAAZ,EAAeR,IAAf,EAAhB,CAAP;AACD;AACD;;AALmB,yBAMM,KAAKR,SAAL,CAAeC,IAAf,CANN;AAAA;AAAA,YAMdgB,OANc;AAAA,YAMFC,IANE;AAOnB;;;AACA,YAAIC,cAAc,SAASF,QAAQG,OAAR,CAAgB,IAAhB,EAAsB,GAAtB,CAA3B;AACA,YAAI,OAAO,KAAKD,WAAL,CAAP,IAA4B,UAAhC,EAA4C;AAC1C,cAAIE,iBAAiB,KAAKF,WAAL,EAAkB/C,KAAlB,CAAwB,IAAxB,EAA8B8C,IAA9B,CAArB;AACA,cAAIG,kBAAkBA,eAAeP,UAAf,CAA0B,GAA1B,CAAlB,IAAoD,KAAKQ,cAAL,EAAxD,EAA+E;AAC7E,iBAAKC,uBAAL,CAA6BF,cAA7B;AACA,mBAAO,IAAP;AACD;AACD,iBAAOA,cAAP;AACD;AACD,cAAM,IAAI3F,KAAJ,yCAAgDuF,OAAhD,OAAN;AACD,OA7IH;;;AA+IE;;;;;;;;;AASAO,iBAxJF,uBAwJcC,MAxJd,EAwJ4C;AAAA;;AAAA,YAAtBC,eAAsB,uEAAN,IAAM;;AACxC,aAAK7C,QAAL,GAAgB,EAAhB;AACA,aAAKC,aAAL,GAAqB,EAArB;AACA,aAAKK,mBAAL,GAA2B,CAAC,CAA5B;AACA,aAAKC,MAAL,GAAc,EAAd;AACA,YAAIuC,QAAQ,EAAZ;AALwC;AAAA;AAAA;;AAAA;AAMxC,gCAAiBF,OAAOhB,KAAP,CAAa,IAAb,CAAjB,mIAAqC;AAAA,gBAA5BR,IAA4B;;AACnCA,mBAAOA,KAAKO,IAAL,EAAP;AACA,gBAAI,CAACP,IAAL,EAAW;AACT;AACD;AACD;AACA,gBAAI2B,UAAU3B,KAAKrC,KAAL,CAAW,sBAAX,CAAd;AACA,gBAAIgE,OAAJ,EAAa;AACX,mBAAKxC,MAAL,CAAYwC,QAAQ,CAAR,CAAZ,IAA0BA,QAAQ,CAAR,CAA1B;AACA;AACD,aAHD,MAGO,IAAIF,mBAAmBzB,KAAKrC,KAAL,CAAW,gBAAX,CAAvB,EAAqD;AAC1DqC,qBAAOA,KAAKmB,OAAL,CAAa,iBAAb,EAAgC;AAAA,kDAAIF,IAAJ;AAAIA,sBAAJ;AAAA;;AAAA,uBAAa,MAAK9B,MAAL,CAAY8B,KAAK,CAAL,CAAZ,CAAb;AAAA,eAAhC,CAAP;AACD;;AAED;AACA,gBAAIjB,KAAKa,UAAL,CAAgB,SAAhB,CAAJ,EAAgC;AAC9B,kBAAI,KAAKQ,cAAL,EAAJ,EAA2B;AACzB,sBAAM,IAAI5F,KAAJ,CAAU,2CAAV,CAAN;AACD;AACD,mBAAKmF,cAAL,CAAoBZ,IAApB;AACA;AACD;;AAED;AACA,gBAAIA,KAAKa,UAAL,CAAgB,QAAhB,CAAJ,EAA+B;AAC7B,mBAAKD,cAAL,CAAoBZ,IAApB;AACD;;AAED;AACA,gBAAIA,SAAS,KAAb,EAAoB;AAClB;AACA,kBAAI,CAAC,KAAKqB,cAAL,EAAL,EAA4B;AAC1B,qBAAKT,cAAL,CAAoBZ,IAApB;AACA;AACD;AACD;AACA,mBAAKY,cAAL,CAAoBZ,IAApB;AACD;;AAED;AACA,gBAAI,KAAKd,mBAAL,IAA4B,CAAhC,EAAmC;AAAA,kBAC5BF,IAD4B,GACpB,KAAKH,aAAL,CAAmB,KAAKK,mBAAxB,CADoB,CAC5BF,IAD4B;;AAEjC,mBAAKJ,QAAL,CAAcI,IAAd,EAAoB2B,IAApB,CAAyBX,IAAzB;AACA;AACD;;AAGD0B,kBAAMf,IAAN,CAAWX,IAAX;AACD;AACD;AAvDwC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAwDxC,YAAIyB,eAAJ,EAAqB;AACnB,eAAKtC,MAAL,GAAc,EAAd;AACD;AACD,eAAOuC,KAAP;AACD,OApNH;;;AAsNE;;;;;;;;AAQAE,eA9NF,qBA8NYC,UA9NZ,EA8NwBZ,IA9NxB,EA8N8B;AAC1B,YAAIa,cAAc,KAAKlD,QAAL,CAAciD,UAAd,CAAlB;AACA,YAAIC,gBAAgB9E,SAApB,EAA+B;AAAA,qCAEpB+E,CAFoB;AAG3BD,0BAAcA,YAAYE,GAAZ,CAAgB;AAAA,qBAAKC,EAAEd,OAAF,CAAU,IAAIe,MAAJ,CAAW,SAASH,IAAI,CAAb,CAAX,EAA4B,GAA5B,CAAV,EAA4CvE,KAAKC,SAAL,CAAewD,KAAKc,CAAL,CAAf,CAA5C,CAAL;AAAA,aAAhB,CAAd;AAH2B;;AAC7B;AACA,eAAK,IAAIA,IAAI,CAAb,EAAgBA,IAAId,KAAK7D,MAAzB,EAAiC2E,GAAjC,EAAsC;AAAA,kBAA7BA,CAA6B;AAErC;AACD,iBAAOD,WAAP;AACD;AACD,eAAO9E,SAAP;AACD,OAxOH;;;AA2OE;;;;;AAKAmF,sBAhPF,8BAgPqB;AAAA;;AACjB,eAAO7H,OAAO8H,mBAAP,CAA2B,KAAKjD,MAAhC,EACJ6C,GADI,CACA;AAAA,4BAAgBK,GAAhB,YAAyB,OAAKlD,MAAL,CAAYkD,GAAZ,CAAzB;AAAA,SADA,CAAP;AAED,OAnPH;;;AAqPE;;;;;;AAMAC,yBA3PF,+BA2PsBtC,IA3PtB,EA2P4B;AAAA;;AACxB,YAAIA,KAAKrC,KAAL,CAAW,gBAAX,CAAJ,EAAkC;AAChCqC,iBAAOA,KAAKmB,OAAL,CAAa,iBAAb,EAAgC,YAAa;AAClD,gBAAIoB,2DAAJ;AACA,gBAAIC,cAAc,OAAKrD,MAAL,CAAYoD,QAAZ,CAAlB;AACA,gBAAIC,gBAAgBxF,SAApB,EAA+B;AAC7B,oBAAM,IAAIvB,KAAJ,gBAAuB8G,QAAvB,6BAAN;AACD;AACD,mBAAOC,WAAP;AACD,WAPM,CAAP;AAQD;AACD,eAAOxC,IAAP;AACD,OAvQH;;;AAyQE;;;;;;;AAOAyC,mCAhRF,yCAgRgCjB,MAhRhC,EAgRwC;AACpC,eAAOlH,OAAO+C,OAAP,CAAe,yCAAqBzC,gBAApC,EACJ8H,MADI,CACG;AAAA;AAAA,cAAE1D,IAAF;;AAAA,iBAAYwC,SAASA,OAAO7D,KAAP,CAAa,IAAIuE,MAAJ,CAAWlD,IAAX,CAAb,CAAT,GAA0C,IAAtD;AAAA,SADH,EAEJgD,GAFI,CAEA;AAAA;AAAA,cAAEhD,IAAF;AAAA,cAAQlE,EAAR;;AAAA,iBAAgBA,GAAG8C,QAAH,GAClBuD,OADkB,CACV,aADU,gBACiBnC,IADjB;AAEnB;AAFmB,WAGlBmC,OAHkB,CAGV,sCAHU,EAG8B,IAH9B,EAIlBX,KAJkB,CAIZ,IAJY,EAKlBwB,GALkB,CAKd;AAAA,mBAAQhC,KAAKO,IAAL,EAAR;AAAA,WALc,EAMlBmC,MANkB,CAMX;AAAA,mBAAQC,QAAQ3C,IAAR,CAAR;AAAA,WANW,EAOlB4C,IAPkB,CAOb,EAPa,CAAhB;AAAA,SAFA,CAAP;AAWD,OA5RH;;;AA8RE;;;;;;;;AAQMC,WAtSR;AAAA,6FAsScnB,KAtSd;AAAA,cAsSqBoB,KAtSrB,uEAsS2B,CAtS3B;AAAA,cAsS8BC,IAtS9B,uEAsSmC,CAtSnC;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,+BAuSqBrB,KAvSrB;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAuSa1B,sBAvSb;;AAAA,sBAySW,KAAKgD,UAAL,EAzSX;AAAA;AAAA;AAAA;;AAAA,mDA0Se,KA1Sf;;AAAA;AAAA,uBA8SUhD,KAAKa,UAAL,CAAgB,GAAhB,CA9SV;AAAA;AAAA;AAAA;;AAAA;;AAAA;;AAkTM;AACAb,yBAAO,KAAKsC,mBAAL,CAAyBtC,IAAzB,CAAP;;AAEA;AArTN,+BAsT+B,KAAKD,SAAL,CAAeC,IAAf,CAtT/B,qCAsTWgB,OAtTX,kBAsTuBC,IAtTvB;AAuTUa,6BAvTV,GAuTwB,KAAKF,SAAL,CAAeZ,OAAf,EAAwBC,IAAxB,CAvTxB;;AAAA,wBAwTUa,gBAAgB9E,SAxT1B;AAAA;AAAA;AAAA;;AAyTQ,sBAAI8F,KAAJ,EAAW;AACTC;AACA,yBAAKE,KAAL,mBAA2BF,IAA3B,WAAqCD,KAArC,0BAA+D9B,OAA/D;AACD;AA5TT;AAAA,yBA6Tc,KAAK6B,KAAL,CAAWf,WAAX,CA7Td;;AAAA;AAAA;;AAAA;;AAiUM;AACA,sBAAIgB,SAAS,CAAC9C,KAAKa,UAAL,CAAgB,MAAhB,CAAV,IAAqC,CAACb,KAAKa,UAAL,CAAgB,OAAhB,CAA1C,EAAoE;AAClEkC;AACA;AACA,yBAAKG,aAAL,CAAmB,UAAnB,EAA+B,CAACH,IAAD,EAAOD,KAAP,CAA/B;AACA,yBAAKG,KAAL,mBAA2BF,IAA3B,WAAqCD,KAArC;AACD;AACD;;AAxUN,wBAyUU,KAAKK,OAAL,OAAiB,MAAjB,IAA2BnD,KAAKa,UAAL,CAAgB,OAAhB,CAzUrC;AAAA;AAAA;AAAA;;AAAA;;AAAA;;AA6UM;AACIuC,sBA9UV,GA8UiB,KAAKxC,cAAL,CAAoBZ,IAApB,CA9UjB;AA+UM;;AA/UN,sBAgVWoD,IAhVX;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAmVM,uBAAKH,KAAL,CAAcjD,IAAd,UAAuB,IAAIqD,MAAJ,CAAW,EAAX,CAAvB,UAA0CD,IAA1C;AACA;AACIE,wBArVV,GAqVmBvE,OAAOwE,IAAP,CAAYH,IAAZ,CArVnB;;AAAA,wBAsVUE,kBAAkBpI,OAtV5B;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA,yBAwVgBoI,MAxVhB;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA,mDA8VW,IA9VX;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AAiWE;;;;;;;AAOME,YAxWR;AAAA,+FAwWehC,MAxWf;AAAA;;AAAA;AAAA;AAAA;AAAA;AAyWI,uBAAKiC,UAAL,CAAgB,IAAhB;AACI/B,uBA1WR,GA0WgB,KAAKH,WAAL,CAAiBC,MAAjB,CA1WhB;AA2WQsB,uBA3WR,GA2WgB,CA3WhB;AA4WQY,6BA5WR,GA4WqB,KA5WrB;AAAA;AAAA;AAAA;AAAA;AAAA,+BA6WqBhC,KA7WrB;;AAAA;AAAA;AAAA;AAAA;AAAA;;AA6Wa1B,sBA7Wb;;AAAA,uBA8WUA,KAAKa,UAAL,CAAgB,QAAhB,CA9WV;AAAA;AAAA;AAAA;;AA+WQ6C,gCAAc,IAAd;AA/WR;;AAAA;AAAA,uBAkXU1D,KAAKa,UAAL,CAAgB,KAAhB,CAlXV;AAAA;AAAA;AAAA;;AAmXQ6C,gCAAc,KAAd;AAnXR;;AAAA;AAsXM,sBAAI,CAACA,WAAD,IAAgB,CAAC1D,KAAKa,UAAL,CAAgB,OAAhB,CAAjB,IAA6C,CAACb,KAAKa,UAAL,CAAgB,GAAhB,CAA9C,IAAsE,CAACb,KAAKa,UAAL,CAAgB,OAAhB,CAA3E,EAAqG;AACnGiC;AACD;;AAxXP;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA,yBA6XY,KAAKD,KAAL,CAAWnB,KAAX,EAAkBoB,KAAlB,EAAyB,CAAzB,CA7XZ;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA,iCA+Xc,KAAKK,OAAL,EA/Xd;AAAA,oDAgYa,MAhYb,yBAkYa,cAlYb;AAAA;;AAAA;AAAA;;AAAA;AAmYU,uBAAKlG,IAAL;;AAnYV;AAsYI,uBAAKwG,UAAL,CAAgB,KAAhB;AACA,uBAAKE,aAAL;;AAvYJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AA0YE;;;;;AAKAC,eA/YF,qBA+YYpC,MA/YZ,EA+YoB;AAChB,eAAO,KAAKqC,UAAL,CAAgBrC,MAAhB,CAAP;AACD,OAjZH;;;AAmZE;;;;;;AAMAqC,gBAzZF,sBAyZarC,MAzZb,EAyZqB;AAAA;;AACjB,YAAIE,QAAQ,KAAKH,WAAL,CAAiBC,MAAjB,CAAZ;AACA,YAAIsC,kBAAkB,KAAK3B,gBAAL,EAAtB;AAFiB;AAAA;AAAA;;AAAA;AAGjB,gCAAiBT,KAAjB,mIAAwB;AAAA,gBAAf1B,IAAe;;AACtBA,mBAAOA,KAAKO,IAAL,EAAP;;AADsB,6BAEG,KAAKR,SAAL,CAAeC,IAAf,CAFH;AAAA;AAAA,gBAEjBgB,OAFiB;AAAA,gBAELC,IAFK;;AAGtB,gBAAIa,cAAc,KAAKF,SAAL,CAAeZ,OAAf,EAAwBC,IAAxB,CAAlB;AACA,gBAAI8C,YAAY,CAACjC,eAAe,CAAC9B,IAAD,CAAhB,EACbgC,GADa,CACT;AAAA,qBAAK,OAAKpB,cAAL,CAAoBqB,CAApB,CAAL;AAAA,aADS,EAEbS,MAFa,CAEN;AAAA,qBAAKC,QAAQV,CAAR,CAAL;AAAA,aAFM,CAAhB;AAGA6B,8BAAkBA,gBAAgBpE,MAAhB,CAAuBqE,SAAvB,CAAlB;AACD;AAXgB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAYjB,YAAIC,cAAcF,gBAAgBlB,IAAhB,CAAqB,IAArB,CAAlB;AACA,eAAO,KAAKH,6BAAL,CAAmCuB,WAAnC,EACJtE,MADI,CACGoE,eADH,EAEJlB,IAFI,CAEC,IAFD,CAAP;AAGD,OAzaH;;;AA2aE;;;;;;;AAOAqB,kCAlbF,wCAkb+BC,SAlb/B,EAkb0CC,UAlb1C,EAkbsD;AAClDrK,WAAGO,IAAH,CAAQ4F,MAAR,CAAeC,YAAf,CAA4BgE,SAA5B;AACAC,qBAAaA,kDAAgDD,SAAhD,mBAAb;AACA,4CAAkCA,SAAlC,UAAgD,KAAKE,WAAL,EAAhD,UAAuE,KAAKhI,UAAL,EAAvE,YAA8F+H,UAA9F;AACD,OAtbH;;;AAwbE;;;;;;;;;;AAUAE,8BAlcF,oCAkc2BC,EAlc3B,EAkc+B1I,IAlc/B,EAkcqC2I,IAlcrC,EAkc2CJ,UAlc3C,EAkcuD;AACnDrK,WAAGO,IAAH,CAAQ4F,MAAR,CAAeC,YAAf,CAA4BoE,EAA5B;AACAxK,WAAGO,IAAH,CAAQ4F,MAAR,CAAeC,YAAf,CAA4BtE,IAA5B;AACA,YAAI9B,GAAGiC,IAAH,CAAQC,IAAR,CAAaC,QAAb,CAAsBsI,IAAtB,KAA+BA,KAAK1D,UAAL,CAAgB,YAAhB,CAAnC,EAAkE;AAChE0D,iBAAOA,KAAKxD,MAAL,CAAY,EAAZ,CAAP;AACD,SAFD,MAEO;AACLwD,iBAAO/G,KAAKC,SAAL,CAAe8G,IAAf,CAAP;AACD;AACD,YAAI,CAACJ,UAAL,EAAiB;AACfA,uDAAyCvI,IAAzC,cAAsD0I,EAAtD;AACD;;AAED,oCAAyBA,EAAzB,cAAkC1I,IAAlC,WAA2C2I,IAA3C,UAAoD,KAAKnI,UAAL,EAApD,YAA2E+H,UAA3E;AACD,OA/cH;;;AAidE;;;;;;;;;;;;;;AAcAK,wCA/dF,8CA+dqCF,EA/drC,EA+dyC1I,IA/dzC,EA+d+C2I,IA/d/C,EA+dqDnB,IA/drD,EA+d2D;AACvDtJ,WAAGO,IAAH,CAAQ4F,MAAR,CAAeC,YAAf,CAA4BoE,EAA5B;AACAxK,WAAGO,IAAH,CAAQ4F,MAAR,CAAeC,YAAf,CAA4BtE,IAA5B;AACA,eAAO,kJAG4C0I,EAH5C,eAGsD1I,IAHtD,aAGgE2I,SAAOvH,SAAP,GAAiB,WAAjB,GAA6BQ,KAAKC,SAAL,CAAe8G,IAAf,CAH7F,WAGsH,KAAKnI,UAAL,EAHtH,wHAOCgH,IAPD,2CAUF5C,KAVE,CAUI,IAVJ,EAUUwB,GAVV,CAUc;AAAA,iBAAKC,EAAE1B,IAAF,EAAL;AAAA,SAVd,EAU6BqC,IAV7B,CAUkC,EAVlC,CAAP;AAWD,OA7eH;;;AA+eE;;;;;AAKA9B,gBApfF,sBAofa2D,OApfb,EAofsB;AAClB,eAAO,QAAQA,OAAf;AACD,OAtfH;;;AAwfE;;;;;AAKAC,uBA7fF,6BA6foBC,CA7fpB,EA6fuB;AACnB,eAAOA,EAAExD,OAAF,CAAU,wBAAV,EAAoC,MAApC,CAAP;AACD,OA/fH;;;AAigBE;;;;;;AAMAyD,mCAvgBF,yCAugBgCD,CAvgBhC,EAugBmC;AAAA;;AAC/B,YAAIE,YAAY,gBAAhB;AACA,YAAIC,eAAeH,EAAEhH,KAAF,CAAQkH,SAAR,CAAnB;AACA,YAAIC,gBAAgBA,aAAa1H,MAAjC,EAAyC;AAAA;AACvC,gBAAIE,QAAM,CAAV;AACA;AACAwH,2BAAeA,aAAa9C,GAAb,CAAiB;AAAA,qBAAK+C,EAAEC,KAAF,CAAQ,CAAR,EAAW,CAAC,CAAZ,CAAL;AAAA,aAAjB,CAAf;AACA;AACA;AAAA,iBAAO,OAAKN,iBAAL,CAAuBC,CAAvB,EAA0BxD,OAA1B,CAAkC0D,SAAlC,EAA6C;AAAA,uBAAMC,aAAaxH,OAAb,CAAN;AAAA,eAA7C;AAAP;AALuC;;AAAA;AAMxC;AACD,eAAO,KAAKoH,iBAAL,CAAuBC,CAAvB,CAAP;AACD,OAlhBH;;;AAohBE;;;;;AAKArD,6BAzhBF,mCAyhB0B2D,WAzhB1B,EAyhBuC;AACnC,YAAI,CAACnL,GAAGiC,IAAH,CAAQC,IAAR,CAAamB,OAAb,CAAqB,KAAKiC,UAA1B,CAAL,EAA4C;AAC1C,gBAAM,IAAI3D,KAAJ,CAAU,0DAAV,CAAN;AACD;AACD,aAAK2D,UAAL,CAAgBuB,IAAhB,CAAqBsE,WAArB;AACD,OA9hBH;;;AAgiBE;;;;AAIAC,4BApiBF,oCAoiB2B;AACvB,cAAM,IAAIzJ,KAAJ,CAAU,8DAAV,CAAN;AACD,OAtiBH;;;AAwiBE;;;;AAIA4F,oBA5iBF,4BA4iBmB;AACf,eAAOvH,GAAGiC,IAAH,CAAQC,IAAR,CAAamB,OAAb,CAAqB,KAAKiC,UAA1B,CAAP;AACD,OA9iBH;;;AAgjBE;;;;;;AAMA;;;;AAIA+F,oBA1jBF,0BA0jBiBC,GA1jBjB,EA0jBsB;AAClB,wEAA6DA,GAA7D,kCAA2FA,GAA3F;AACD,OA5jBH;;;AA8jBE;;;;AAIAC,0BAlkBF,gCAkkBuBC,UAlkBvB,EAkkBmC;AAC/B,YAAI,KAAKnC,OAAL,OAAiB,cAArB,EAAqC;AACnC,kEAAqDmC,UAArD,gGAAwJA,UAAxJ,uBAAkL,KAAKxG,UAAvL;AACD;AACD,uEAA4DwG,UAA5D,0CAAyGA,UAAzG;AACD,OAvkBH;;;AAykBE;;;;;AAKAC,yBA9kBF,+BA8kBsBvH,IA9kBtB,EA8kB4B;AACxB,6BAAkB,KAAKc,UAAvB,sBAAgDd,IAAhD;AACD,OAhlBH;;;AAklBE;;;;;AAKAwH,gBAvlBF,sBAulBa3D,UAvlBb,EAulByB;AACrB,YAAI,KAAKjD,QAAL,CAAciD,UAAd,MAA8B7E,SAAlC,EAA6C;AAC3C,gBAAM,IAAIvB,KAAJ,2BAAkCoG,UAAlC,kDAAN;AACD;AACD,YAAIvE,QAAQ,EAAE,KAAK4B,mBAAnB;AACA,aAAKL,aAAL,CAAmBvB,KAAnB,IAA4B,EAAE0B,MAAM6C,UAAR,EAA5B;AACA,aAAKjD,QAAL,CAAciD,UAAd,IAA4B,EAA5B;AACA,eAAO,IAAP;AACD,OA/lBH;;;AAimBE;;;;AAIA4D,aArmBF,qBAqmBY;AACR,YAAI,KAAKrG,UAAT,EAAqB;AACnB,cAAIY,OAAO,KAAKZ,UAAL,CAAgBhC,MAAhB,sBAA0C,KAAKgC,UAAL,CAAgBwD,IAAhB,CAAqB,GAArB,CAA1C,WAA2E,IAAtF;AACA,eAAKxD,UAAL,GAAkB,IAAlB;AACA,iBAAOY,IAAP;AACD;AACD,YAAI,KAAKd,mBAAL,GAA2B,CAA/B,EAAkC;AAChC,gBAAM,IAAIzD,KAAJ,qBAAN;AACD;AACD,aAAKyD,mBAAL;AACA,eAAO,IAAP;AACD,OAhnBH;;;AAknBE;;;;AAIAwG,mBAtnBF,2BAsnBkB;AACd,aAAKtG,UAAL,GAAgB,EAAhB;AACA,eAAO,IAAP;AACD;AAznBH;AA9N0D,GAA5D,C;AAnBA5E,aAAWC,aAAX,CAAyBkL,MAAzB,CAAgCC,QAAhC,CAAyC3L,aAAzC,GAAyDA,aAAzD",
  "file": "Abstract.js",
  "sourcesContent": [
    "/* ************************************************************************\n\n  UI Event Recorder\n\n  Copyright:\n    2018 Christian Boulanger\n\n  License:\n    MIT license\n    See the LICENSE file in the project's top-level directory for details.\n\n  Authors: Christian Boulanger\n\n************************************************************************ */\n\n/**\n * The base class of all player types\n * @require(qx.bom.Element)\n */\nqx.Class.define(\"cboulanger.eventrecorder.player.Abstract\", {\n  extend : qx.core.Object,\n  include : [cboulanger.eventrecorder.MHelperMethods],\n\n  statics: {\n    utilityFunctions : {\n      /**\n       * Runs the given function in the interval until it returns true or the\n       * given timeout is reached. Returns a promise that will resolve once the\n       * function returns true or rejects if the timeout is reached.\n       * @param fn {Function} Condition function\n       * @param interval {Number} The interval in which to run the function. Defaults to 100 ms.\n       * @param timeout {Number} The timeout in milliseconds. Defaults to 10 seconds\n       * @param timeoutMsg {String|undefined} An optional addition to the timeout error message\n       * @return {Promise}\n       */\n      waitForCondition: function(fn, interval=100, timeout=10000, timeoutMsg) {\n        return new Promise(((resolve, reject) => {\n          let intervalId = setInterval(() => {\n            if (fn()) {\n              clearInterval(intervalId);\n              resolve();\n            }\n          }, interval);\n          setTimeout(() => {\n            clearInterval(intervalId);\n            reject(new Error(timeoutMsg || `Timeout waiting for condition.`));\n          }, timeout);\n        }));\n      },\n\n      /**\n       * Returns a promise that will resolve (with any potential event data) if\n       * the given object fires an event with the given type and will reject if\n       * the timeout is reached before that happens.\n       *\n       * @param qxObjOrId {qx.core.Object|String} If string, assume it is the object id\n       * @param type {String} Type of the event\n       * @param expectedData {*|undefined} The data to expect. If undefined,\n       * resolve. If a regular expression, the event data as a JSON literal will\n       * be matched with that regex and the promise will resolve when it matches.\n       * Otherwise, the data will be compared with the actual event data both\n       * serialized to JSON.\n       * @param timeout {Number|undefined} The timeout in milliseconds. Defaults to 10 seconds\n       * @param timeoutMsg {String|undefined} An optional addition to the timeout error message\n       * @return {Promise}\n       */\n      waitForEvent: function(qxObjOrId, type, expectedData, timeout, timeoutMsg) {\n        let qxObj = qxObjOrId;\n        if (qx.lang.Type.isString(qxObjOrId)) {\n          qxObj = qx.core.Id.getQxObject(qxObjOrId);\n          if (!qxObj) {\n            throw new Error(`Invalid object id ${qxObjOrId}`);\n          }\n        }\n        timeout = timeout || this.getTimeout();\n\n        return new Promise(((resolve, reject) => {\n          // create a timeout\n          let timeoutId = setTimeout(() => {\n            qxObj.removeListener(type, changeEventHandler);\n            reject(new Error(timeoutMsg || `Timeout waiting for event \"${type}.`));\n          }, timeout);\n\n          // function to create a listener for the change event\n          let changeEventHandler = e => {\n            let app = qx.core.Init.getApplication();\n            let eventdata = e instanceof qx.event.type.Data ? e.getData() : undefined;\n            if (expectedData !== undefined) {\n              if (eventdata === undefined) {\n                app.warn(`\\n--- When waiting for event '${type}' on object ${qxObj}, received 'undefined'`);\n                qxObj.addListenerOnce(type, changeEventHandler);\n                return;\n              }\n              if (qx.lang.Type.isArray(expectedData) && qx.lang.Type.isArray(eventdata) && expectedData.length && expectedData[0] instanceof qx.core.Object) {\n                /** a) either match array and check for \"live\" qooxdoo objects in the array (this is for selections), */\n                for (let [index, expectedItem] of expectedData.entries()) {\n                  if (expectedItem !== eventdata[index]) {\n                    app.warn(`\\n--- When waiting for event '${type}' on object ${qxObj}, received non-matching array of qooxdoo objects!`);\n                    qxObj.addListenerOnce(type, changeEventHandler);\n                    return;\n                  }\n                }\n              } else {\n                // convert event data to JSON\n                try {\n                  eventdata = JSON.stringify(e.getData());\n                } catch (e) {\n                  throw new Error(`\\n--- When waiting for event '${type}' on object ${qxObj}, could not stringify event data for comparison.`);\n                }\n                if (qx.lang.Type.isRegExp(expectedData)) {\n                  /** b) or match a regular expression, */\n                  if (!eventdata.match(expectedData)) {\n                    app.warn(`\\n--- When waiting for event '${type}' on object ${qxObj}, expected data to match '${expectedData.toString()}', got ${eventdata}!`);\n                    qxObj.addListenerOnce(type, changeEventHandler);\n                    return;\n                  }\n                } else {\n                  /* c) or compare JSON equality */\n                  try {\n                    expectedData = JSON.stringify(expectedData);\n                  } catch (e) {\n                    throw new Error(`When waiting for event '${type}' on object ${qxObj}, could not stringify expected data for comparison.`);\n                  }\n                  if (eventdata !== expectedData) {\n                    app.warn(`\\n--- When waiting for event '${type}' on object ${qxObj}, expected '${JSON.stringify(expectedData)}', got '${JSON.stringify(eventdata)}'!\"`);\n                    qxObj.addListenerOnce(type, changeEventHandler);\n                    return;\n                  }\n                }\n              }\n            }\n            app.info(`\\n+++ Received correct event '${type}' on object ${qxObj}.\"`);\n            clearTimeout(timeoutId);\n            resolve(eventdata);\n          };\n\n          // add a listener\n          qxObj.addListenerOnce(type, changeEventHandler);\n        }));\n      }\n    }\n  },\n\n  properties: {\n    /**\n     * The replay mode. Possible values:\n     * \"test\": The script is executed ignoring the \"delay\" commands, errors will\n     * stop execution and will be thrown.\n     * \"presentation\": The script is executed with user delays, errors will be\n     * logged to the console but will not stop execution\n     */\n    mode: {\n      check: [\"test\", \"presentation\"],\n      event: \"changeMode\",\n      init: \"presentation\",\n      apply: \"_applyMode\"\n    },\n\n    /**\n     * The timeout in milliseconds\n     */\n    timeout: {\n      check: \"Number\",\n      init: 10000\n    },\n\n    /**\n     * The interval between checks if waiting for a condition to fulfil\n     */\n    interval: {\n      check: \"Number\",\n      init: 100\n    },\n\n    /**\n     * if true, ignore user delays and use defaultDelay\n     */\n    useDefaultDelay: {\n      check: \"Boolean\",\n      nullable: false,\n      init: false\n    },\n\n    /**\n     * The maximun delay between events (limits user-generated delay)\n     */\n    maxDelay: {\n      check: \"Number\",\n      init: 1000\n    },\n\n    /**\n     * Whether the player can replay the generated script in the browser\n     */\n    canReplayInBrowser: {\n      check: \"Boolean\",\n      nullable: false,\n      init: false,\n      event: \"changeCanReplay\"\n    },\n\n    /**\n     * Whether the player can export code that can be used outside this application\n     */\n    canExportExecutableCode: {\n      check: \"Boolean\",\n      nullable: false,\n      init: false,\n      event: \"changeCanExportExecutableCode\"\n    }\n  },\n\n  events: {\n    /**\n     * Fired with each step of the replayed script. The event data is an array\n     * containing the number of the step and the number of steps\n     */\n    \"progress\" : \"qx.event.type.Data\"\n  },\n\n  /**\n   * constructor\n   */\n  construct: function() {\n    this.base(arguments);\n    this.__commands = [];\n    this.__macros = [];\n    this.__macro_stack = [];\n    this._globalRef = \"eventrecorder_player\";\n    window[this._globalRef] = this;\n    // inject utility functions in the statics section into the global scope\n    // so that they are available in eval()\n    for (let [name, fn] of Object.entries(this.self(arguments).utilityFunctions)) {\n      window[name] = fn;\n    }\n  },\n\n  /**\n   * The methods and simple properties of this class\n   */\n  members :\n  {\n    /**\n     * A globally accessible reference to the player implementation\n     */\n    _globalRef: null,\n\n    /**\n     * A list of available commands\n     */\n    __commands: null,\n\n    /**\n     * An object mapping macro names to arrays containing the macro lines\n     * @var {Object}\n     */\n    __macros : null,\n\n    /**\n     * An array of object containing information on the macros that are currently\n     * being defined (in a nested way)\n     * @var {Object[]}\n     */\n    __macro_stack: null,\n\n    /**\n     * The index of the macro in the macro stack that is currently defined\n     * @var {Integer}\n     */\n    __macro_stack_index: -1,\n\n    /**\n     * Variables\n     */\n    __vars: null,\n\n    /**\n     * An array of promises which are to be awaited\n     */\n    __promises: null,\n\n    /**\n     * Stub to be overridden if needed\n     * @param value\n     * @param old\n     * @private\n     */\n    _applyMode(value, old) {},\n\n    /**\n     * NOT IMPLEMENTED\n     * Adds the given array of commands\n     * @param commands {Object[]}\n     */\n    _addCommands(commands) {\n      this.__commands = this.__commands.concat(commands).sort((a, b) => a.name > b.name);\n    },\n\n    /**\n     * NOT IMPLEMENTED\n     * Returns the list of availabe commands\n     * @return {Object[]}\n     */\n    getCommands() {\n      return this.__commands;\n    },\n\n    /**\n     * Simple tokenizer which splits expressions separated by whitespace, but keeps\n     * expressions in quotes (which can contain whitespace) together. Parses tokens\n     * as JSON expressions, but accepts unquoted text as strings.\n     * @param line {String}\n     * @return {String[]}\n     * @private\n     */\n    _tokenize(line) {\n      qx.core.Assert.assertString(line);\n      let tokens = [];\n      let token = \"\";\n      let prevChar=\"\";\n      let insideQuotes = false;\n      for (let char of line.trim().split(\"\")) {\n        switch (char) {\n          case \"\\\"\":\n            insideQuotes=!insideQuotes;\n            token += char;\n            break;\n          case \" \":\n            // add whitespace to token if inside quotes\n            if (insideQuotes) {\n              token += char;\n              break;\n            }\n            // when outside quotes, whitespace is end of token\n            if (prevChar !== \" \") {\n              // parse token as json expression or as a string if that fails\n              try {\n                token = JSON.parse(token);\n              } catch (e) {}\n              tokens.push(token);\n              token = \"\";\n            }\n            break;\n          default:\n            token += char;\n        }\n        prevChar = char;\n      }\n      if (token.length) {\n        try {\n          token = JSON.parse(token);\n        } catch (e) {}\n        tokens.push(token);\n      }\n      return tokens;\n    },\n\n    /**\n     * Translates a single line from the intermediate code into the target\n     * language. To be overridden by subclasses if neccessary.\n     *\n     * @param line {String}\n     * @return {String}\n     */\n    _translateLine(line) {\n      // comment\n      if (line.startsWith(\"#\")) {\n        return this.addComment(line.substr(1).trim());\n      }\n      // parse command line\n      let [command, ...args] = this._tokenize(line);\n      // run command generation implementation\n      let method_name = \"cmd_\" + command.replace(/-/g, \"_\");\n      if (typeof this[method_name] == \"function\") {\n        let translatedLine = this[method_name].apply(this, args);\n        if (translatedLine && translatedLine.startsWith(\"(\") && this.isInAwaitBlock()) {\n          this._addPromiseToAwaitStack(translatedLine);\n          return null;\n        }\n        return translatedLine;\n      }\n      throw new Error(`Unsupported/unrecognized command: '${command}'`);\n    },\n\n    /**\n     * Given a script, return an array of lines with all variable and macro\n     * declarations registered and removed. Optionally, variables are expanded.\n     *\n     * @param script {String}\n     * @param expandVariables {Boolean} Whether to expand the found variables. Default to true\n     * @return {Array}\n     * @private\n     */\n    _handleMeta(script, expandVariables=true) {\n      this.__macros = {};\n      this.__macro_stack = [];\n      this.__macro_stack_index = -1;\n      this.__vars = {};\n      let lines = [];\n      for (let line of script.split(/\\n/)) {\n        line = line.trim();\n        if (!line) {\n          continue;\n        }\n        // expand variables\n        let var_def = line.match(/([^=\\s]+)\\s*=\\s*(.+)/);\n        if (var_def) {\n          this.__vars[var_def[1]] = var_def[2];\n          continue;\n        } else if (expandVariables && line.match(/\\$([^\\s\\d\\/]+)/)) {\n          line = line.replace(/\\$([^\\s\\d\\/]+)/g, (...args) => this.__vars[args[1]]);\n        }\n\n        // register macros\n        if (line.startsWith(\"define \")) {\n          if (this.isInAwaitBlock()) {\n            throw new Error(\"You cannot use a macro in an await block.\");\n          }\n          this._translateLine(line);\n          continue;\n        }\n\n        // await block\n        if (line.startsWith(\"await-\")) {\n          this._translateLine(line);\n        }\n\n        // end await block or macro\n        if (line === \"end\") {\n          // macro\n          if (!this.isInAwaitBlock()) {\n            this._translateLine(line);\n            continue;\n          }\n          // await block\n          this._translateLine(line);\n        }\n\n        // add code to macro\n        if (this.__macro_stack_index >= 0) {\n          let {name} = this.__macro_stack[this.__macro_stack_index];\n          this.__macros[name].push(line);\n          continue;\n        }\n\n\n        lines.push(line);\n      }\n      // remove variable registration if they have been expanded\n      if (expandVariables) {\n        this.__vars = {};\n      }\n      return lines;\n    },\n\n    /**\n     * Returns the lines for the macro of the given name. If it doesn't exist,\n     * return undefined\n     * @param macro_name {String}\n     * @param args {Array}\n     * @return {Array|undefined}\n     * @private\n     */\n    _getMacro(macro_name, args) {\n      let macro_lines = this.__macros[macro_name];\n      if (macro_lines !== undefined) {\n        // argument placeholders\n        for (let i = 0; i < args.length; i++) {\n          macro_lines = macro_lines.map(l => l.replace(new RegExp(\"\\\\$\" + (i + 1), \"g\"), JSON.stringify(args[i])));\n        }\n        return macro_lines;\n      }\n      return undefined;\n    },\n\n\n    /**\n     * Returns an array of lines containing variable declarations\n     * @return {string[]}\n     * @private\n     */\n    _defineVariables() {\n      return Object.getOwnPropertyNames(this.__vars)\n        .map(key => `const ${key} =\"${this.__vars[key]}\";`);\n    },\n\n    /**\n     * Translates variables in a line\n     * @param line {String}\n     * @private\n     * @return {String}\n     */\n    _translateVariables(line) {\n      if (line.match(/\\$([^\\s\\d\\/]+)/)) {\n        line = line.replace(/\\$([^\\s\\d\\/]+)/g, (...args) => {\n          let var_name = args[1];\n          let var_content = this.__vars[var_name];\n          if (var_content === undefined) {\n            throw new Error(`Variable '${var_name}' has not been defined.`);\n          }\n          return var_content;\n        });\n      }\n      return line;\n    },\n\n    /**\n     * Returns the code of utility functions needed for the command implementations.\n     * @param script {String} Optional script code to be searched for the function name.\n     * If given, omit function if not present in the script code\n     * @return {string[]}\n     * @private\n     */\n    _generateUtilityFunctionsCode(script) {\n      return Object.entries(this.self(arguments).utilityFunctions)\n        .filter(([name]) => script ? script.match(new RegExp(name)) : true)\n        .map(([name, fn]) => fn.toString()\n          .replace(/function \\(/, `function ${name}(`)\n          // remove comments, see https://stackoverflow.com/questions/5989315/regex-for-match-replacing-javascript-comments-both-multiline-and-inline\n          .replace(/\\/\\*[\\s\\S]*?\\*\\/|([^\\\\:]|^)\\/\\/.*$/gm, \"$1\")\n          .split(/\\n/)\n          .map(line => line.trim())\n          .filter(line => Boolean(line))\n          .join(\"\")\n        );\n    },\n\n    /**\n     * Replays a number of script lines\n     * @param lines {String[]}\n     * @param steps {Integer?}\n     * @param step {Integer?}\n     * @return {Promise<boolean>}\n     * @private\n     */\n    async _play(lines, steps=0, step=0) {\n      for (let line of lines) {\n        // stop if we're not running (user pressed \"stop\" button\n        if (!this.getRunning()) {\n          return false;\n        }\n\n        // ignore comments\n        if (line.startsWith(\"#\")) {\n          continue;\n        }\n\n        // variables\n        line = this._translateVariables(line);\n\n        // play macros recursively\n        let [command, ...args] = this._tokenize(line);\n        let macro_lines = this._getMacro(command, args);\n        if (macro_lines !== undefined) {\n          if (steps) {\n            step++;\n            this.debug(`\\n===== Step ${step} / ${steps}, executing macro ${command} =====`);\n          }\n          await this._play(macro_lines);\n          continue;\n        }\n\n        // count steps if given, wait doesn't count as a step\n        if (steps && !line.startsWith(\"wait\") && !line.startsWith(\"delay\")) {\n          step++;\n          // inform listeners\n          this.fireDataEvent(\"progress\", [step, steps]);\n          this.debug(`\\n===== Step ${step} / ${steps} ====`);\n        }\n        // ignore delay in test mode\n        if (this.getMode()===\"test\" && line.startsWith(\"delay\")) {\n          continue;\n        }\n\n        // translate\n        let code = this._translateLine(line);\n        // skip empty lines\n        if (!code) {\n          continue;\n        }\n        this.debug(`${line}\\n${\"-\".repeat(40)}\\n${code}`);\n        // execute\n        let result = window.eval(code);\n        if (result instanceof Promise) {\n          try {\n            await result;\n          } catch (e) {\n            throw e;\n          }\n        }\n      }\n      return true;\n    },\n\n    /**\n     * Replays the given script of intermediate code\n     * @param script {String} The script to replay\n     * @return {Promise} Promise which resolves when the script has been replayed, or\n     * rejects with an error\n     * @todo implement pausing\n     */\n    async replay(script) {\n      this.setRunning(true);\n      let lines = this._handleMeta(script);\n      let steps = 0;\n      let await_block= false;\n      for (let line of lines) {\n        if (line.startsWith(\"await-\")) {\n          await_block = true;\n          continue;\n        }\n        if (line.startsWith(\"end\")) {\n          await_block = false;\n          continue;\n        }\n        if (!await_block && !line.startsWith(\"wait \") && !line.startsWith(\"#\") && !line.startsWith(\"delay\")) {\n          steps++;\n        }\n      }\n\n      // replay it!\n      try {\n        await this._play(lines, steps, 0);\n      } catch (e) {\n        switch (this.getMode()) {\n          case \"test\":\n            throw e;\n          case \"presentation\":\n            this.warn(e);\n        }\n      }\n      this.setRunning(false);\n      this.cmd_hide_info();\n    },\n\n    /**\n     * Translates the intermediate code into the target language\n     * @param script\n     * @return {string} executable code\n     */\n    translate(script) {\n      return this._translate(script);\n    },\n\n    /**\n     * Implementation for #translate()\n     * @param script\n     * @return {string}\n     * @private\n     */\n    _translate(script) {\n      let lines = this._handleMeta(script);\n      let translatedLines = this._defineVariables();\n      for (let line of lines) {\n        line = line.trim();\n        let [command, ...args] = this._tokenize(line);\n        let macro_lines = this._getMacro(command, args);\n        let new_lines = (macro_lines || [line])\n          .map(l => this._translateLine(l))\n          .filter(l => Boolean(l));\n        translatedLines = translatedLines.concat(new_lines);\n      }\n      let translation = translatedLines.join(\"\\n\");\n      return this._generateUtilityFunctionsCode(translation)\n        .concat(translatedLines)\n        .join(\"\\n\");\n    },\n\n    /**\n     * Given an async piece of code which checks for a condition or an application state,\n     * return code that checks for this condition, throwing an error if the\n     * condition hasn't been fulfilled within the set timeout.\n     * @param condition {String} The condition expression as a string\n     * @param timeoutmsg {String|undefined} An optional message to be shown if the condition hasn't been met before the timeout.\n     */\n    generateWaitForConditionCode(condition, timeoutmsg) {\n      qx.core.Assert.assertString(condition);\n      timeoutmsg = timeoutmsg || `Timeout waiting for condition '${condition}' to fulfil.\"`;\n      return `(waitForCondition(() => ${condition}, ${this.getInterval()}, ${this.getTimeout()}, \"${timeoutmsg}\"))`;\n    },\n\n    /**\n     * Generates code that returns a promise which will resolve (with any potential event data) if the given object fires\n     * an event with the given type and data (if applicable) and will reject if the timeout is reached before that happens.\n     * @param id {String} The id of the object to monitor\n     * @param type {String} The type of the event to wait for\n     * @param data {*|undefined} The data to expect. Must be serializable to JSON. Exception: if the data is a string that\n     * starts with \"{verbatim}\", the unquoted string is used\n     * @param timeoutmsg {String|undefined} An optional message to be shown if the event hasn't been fired before the timeout.\n     * @return {String}\n     */\n    generateWaitForEventCode(id, type, data, timeoutmsg) {\n      qx.core.Assert.assertString(id);\n      qx.core.Assert.assertString(type);\n      if (qx.lang.Type.isString(data) && data.startsWith(\"{verbatim}\")) {\n        data = data.substr(10);\n      } else {\n        data = JSON.stringify(data);\n      }\n      if (!timeoutmsg) {\n        timeoutmsg=`Timeout waiting for event '${type}' on '${id}'`;\n      }\n\n      return `(waitForEvent(\"${id}\", \"${type}\",${data}, ${this.getTimeout()}, \"${timeoutmsg}\"))`;\n    },\n\n    /**\n     * Generates code that returns a promise which will resolve (with any\n     * potential event data) if the given object fires an event with the given\n     * type and data (if applicable). After the timeout, it will execute the\n     * given code and restart the timeout.\n     *\n     * @param id {String} The id of the object to monitor\n     * @param type {String} The type of the event to wait for\n     * @param data {*|null} The data to expect. Must be serializable to JSON. In case\n     * of events that do not have data, you MUST explicitly pass 'undefined' as\n     * argument if you use the following arguments\n     * @param code {String} The code to execute after the timeout\n     * @return {String}\n     */\n    generateWaitForEventTimoutFunction(id, type, data, code) {\n      qx.core.Assert.assertString(id);\n      qx.core.Assert.assertString(type);\n      return `(new Promise(async (resolve, reject) => { \n        while (true){\n          try {\n            await waitForEvent(qx.core.Id.getQxObject(\"${id}\"), \"${type}\", ${data===undefined?\"undefined\":JSON.stringify(data)}, ${this.getTimeout()});\n            return resolve(); \n          } catch (e) {\n            console.debug(e.message);\n            ${code};\n          }\n        }\n      }))`.split(/\\n/).map(l => l.trim()).join(\"\");\n    },\n\n    /**\n     * Adds a line comment to the target script\n     * @param comment {String}\n     * @return {string}\n     */\n    addComment(comment) {\n      return \"// \" + comment;\n    },\n\n    /**\n     * Escapes all characters in a string that are special characters in a regular expression\n     * @param s {String} The string to escape\n     * @return {String}\n     */\n    escapeRegexpChars(s) {\n      return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n    },\n\n    /**\n     * Creates a regular expression that matches a json string. In this string, you can use a regular expression\n     * enclosed by \"<!\" and \"!>\" to replace data that cannot be known in advance, such as tokens or session ids.\n     * Example: '{token:\"<![A-Za-z0-9]{32}!>\",user:\"admin\">' will match '{\"token\":\"OnBHqQd59VHZYcphVADPhX74q0Sc6ERR\",\"user\":\"admin\"}'\n     * @param s {string}\n     */\n    createRegexpForJsonComparison(s) {\n      let searchExp = /<![^<][^!]+!>/g;\n      let foundRegExps = s.match(searchExp);\n      if (foundRegExps && foundRegExps.length) {\n        let index=0;\n        // remove escape sequence\n        foundRegExps = foundRegExps.map(m => m.slice(2, -2));\n        // replace placeholders\n        return this.escapeRegexpChars(s).replace(searchExp, () => foundRegExps[index++]);\n      }\n      return this.escapeRegexpChars(s);\n    },\n\n    /**\n     * Adds promise code to a list of promises that need to resolve before the\n     * script proceeds\n     * @param promiseCode\n     */\n    _addPromiseToAwaitStack(promiseCode) {\n      if (!qx.lang.Type.isArray(this.__promises)) {\n        throw new Error(\"Cannot add promise since no await block has been opened.\");\n      }\n      this.__promises.push(promiseCode);\n    },\n\n    /**\n     * Returns the file extension of the downloaded file in the target language\n     * @return {string}\n     */\n    getExportFileExtension() {\n      throw new Error(\"Method getExportFileExtension must be impemented in subclass\");\n    },\n\n    /**\n     * Whether the player is in an await block\n     * @return {Boolean}\n     */\n    isInAwaitBlock() {\n      return qx.lang.Type.isArray(this.__promises);\n    },\n\n    /*\n    ============================================================================\n       COMMANDS\n    ============================================================================\n    */\n\n    /**\n     * Asserts that the current url matches the given value (RegExp)\n     * @param uri {String}\n     */\n    cmd_assert_uri(uri) {\n      return `qx.core.Assert.assertEquals(window.location.href, \"${uri}\", \"Script is valid on '${uri}' only'\")`;\n    },\n\n    /**\n     * Asserts that the current url matches the given value (RegExp)\n     * @param uri_regexp {String} A string containing a regular expression\n     */\n    cmd_assert_match_uri(uri_regexp) {\n      if (this.getMode()===\"presentation\") {\n        return `if(!window.location.href.match(new RegExp(\"${uri_regexp}\"))){alert(\"The eventrecorder script is meant to be played on a website that matches '${uri_regexp}'.\");window[\"${this._globalRef}\"].stop();}`;\n      }\n      return `qx.core.Assert.assertMatch(window.location.href, \"${uri_regexp}\", \"Current URL does not match '${uri_regexp}'\")`;\n    },\n\n    /**\n     * Sets the player mode\n     * @param mode\n     * @return {string}\n     */\n    cmd_config_set_mode(mode) {\n      return `window[\"${this._globalRef}\"].setMode(\"${mode}\");`;\n    },\n\n    /**\n     * Starts the definition of a macro\n     * @param macro_name\n     * @return {null}\n     */\n    cmd_define(macro_name) {\n      if (this.__macros[macro_name] !== undefined) {\n        throw new Error(`Cannot define macro '${macro_name}' since a macro of that name already exists.`);\n      }\n      let index = ++this.__macro_stack_index;\n      this.__macro_stack[index] = { name: macro_name };\n      this.__macros[macro_name] = [];\n      return null;\n    },\n\n    /**\n     * Ends the definition of a macro or a block of awaitable statements\n     * @return {null}\n     */\n    cmd_end() {\n      if (this.__promises) {\n        let line = this.__promises.length ? `(Promise.all([${this.__promises.join(\",\")}]))` : null;\n        this.__promises = null;\n        return line;\n      }\n      if (this.__macro_stack_index < 0) {\n        throw new Error(`Unexpected 'end'.`);\n      }\n      this.__macro_stack_index--;\n      return null;\n    },\n\n    /**\n     * Starts a block of statements that return promises. The player will wait for\n     * all of the promises to resolve before proceeding.\n     */\n    cmd_await_all() {\n      this.__promises=[];\n      return null;\n    }\n  }\n});\n"
  ]
}